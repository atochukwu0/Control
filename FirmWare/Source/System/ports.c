
//*************************************************************************************************
//
// Сканирование дискретных портов (входы состояния устройств)
//
//*************************************************************************************************

#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <stdbool.h>

#include "cmsis_os2.h"

#include "rte_device.h"
#include "lpc177x_8x_gpio.h"

#include "main.h"
#include "ports.h"
#include "rs485.h"
#include "priority.h"
#include "dev_data.h"
#include "events.h"

//*************************************************************************************************
// Локальные константы
//*************************************************************************************************
//номера пинов для контроля состояния
#define FUSE24VDC           28              //Наличие питания контроллера по цепи +24V
#define CNTRL_ON            24              //Наличия питания +12V от схемы управления контакторами
#define UZFS                24              //см. выше
#define BAT_ON              3               //Состояние автомата подключения АКБ
#define SD_DETECT           12              //Наличия установленной SD карты

//частота переключения контрольного светодиода
typedef enum {
    LED_SLOW,                               //медленно 1 Hz
    LED_MIDLE,                              //средняя 2 Hz
    LED_FAST                                //быстро 4 Hz
 } LedFreq;

//*************************************************************************************************
// Локальные переменные
//*************************************************************************************************
PORTS ports;
static uint8_t step = 0, wait = 0;
static uint32_t result_scan, scan1, scan2;
static uint16_t led_mode, led_divide;

//*************************************************************************************************
// Атрибуты объектов RTOS
//*************************************************************************************************
static const osThreadAttr_t ports_attr = {
    .name = "Ports",
    .stack_size = 256,
    .priority = osPriorityNormal,
 };

//*************************************************************************************************
// Прототипы локальных функций
//*************************************************************************************************
void TIMER1_IRQHandler( void );
static uint32_t ScanDataPort( void );
static void LedMode( LedFreq mode );
static void LedBlink( void );
static void ScanData( void );
static void TaskPorts( void *pvParameters );

//*************************************************************************************************
// Инициализация портов
//*************************************************************************************************
void PortsInit( void ) {

    GPIO_SetDir( PORT4, FUSE24VDC, GPIO_DIR_INPUT );
    GPIO_SetDir( PORT3, BAT_ON, GPIO_DIR_INPUT );
    GPIO_SetDir( PORT3, UZFS, GPIO_DIR_INPUT );
    GPIO_SetDir( PORT3, CNTRL_ON, GPIO_DIR_INPUT );
    //порт управления контрольным индикатором
    GPIO_SetDir( CHECK_PORT, CHECK_LED, GPIO_DIR_OUTPUT );
    LedMode( LED_MIDLE );
    //состояния портов еще не выполнено, произведем однократное чтение состояния портов
    result_scan = ScanDataPort();
    //заполним структуру результатом
    ports.fuse_24vdc = Fuse24Vdc();
    ports.bat_connect = BatConn();
    ports.stat_ctrl = StatCtrl();
    ports.cpu_mode = CPUMode();
    ports.state = result_scan;
    //создаем задачу сканирования портов ввода
    osThreadNew( TaskPorts, NULL, &ports_attr );
 }

//*************************************************************************************************
// Задачу сканирования портов ввода
//*************************************************************************************************
static void TaskPorts( void *pvParameters ) {

    uint32_t msg;
    
    for ( ;; ) {
        ScanData(); //сканирования портов ввода
        WDTReset(); //перезапуск WDT
        LedBlink(); //контрольный индикатор
        if ( wait++ > 10 ) {
            wait = 0;
            //отправка данных с интервалом 200 msec
            //при изменении интервала, в модуле HMI необходимо
            //изменить время отсутствия CAN пакетов
            msg = ID_DEV_PORTS;
            osMessageQueuePut( hmi_msg, &msg, 0, 0 ); 
           }
        osDelay( 20 );
       }
 }

//*************************************************************************************************
// Чтение данных/сканирования входов с устранением дребезга
// Результат помещаем в result_scan, значение читаем с помощью GetDataPort()
//*************************************************************************************************
static void ScanData( void ) {

    if ( step == 0 )
        scan1 = ScanDataPort();
    if ( step == 1 )
        scan2 = ScanDataPort();
    step++;
    if ( step == 2 ) {
        //сканирование завершено
        step = 0;
        result_scan = scan1 & scan2;
        //заполним структуру результатом
        ports.fuse_24vdc = Fuse24Vdc();
        ports.bat_connect = BatConn();
        ports.stat_ctrl = StatCtrl();
        ports.cpu_mode = CPUMode();
        ports.state = result_scan;
       } 
 }

//*************************************************************************************************
// Возвращает состояние переключателей MODE
// return = CPU_MODE1_IN
//          CPU_MODE2_IN
//          CPU_MODE1_IN | CPU_MODE2_IN
//*************************************************************************************************
uint8_t CPUMode( void ) {

    uint8_t result = 0;
    
    if ( !GPIO_PinRead( PORT0, CPU_MODE1_IN ) )
        result |= 0x01;
    if ( !GPIO_PinRead( PORT0, CPU_MODE2_IN ) )
        result |= 0x02;
    return result;
 }

//*************************************************************************************************
// Управление индикатором состояния
//*************************************************************************************************
static void LedBlink( void ) {

    if ( led_divide ) {
        led_divide--;
        return;
       }
    led_divide = led_mode;
    if ( GPIO_PinRead( CHECK_PORT, CHECK_LED ) )
        GPIO_PinWrite( CHECK_PORT, CHECK_LED, LED_OFF );
    else GPIO_PinWrite( CHECK_PORT, CHECK_LED, LED_ON );
 }

//*************************************************************************************************
// Установка частоты переключения контрольного светодиода
// LedFreq mode - частота переключения
//*************************************************************************************************
static void LedMode( LedFreq mode ) {

    if ( mode == LED_SLOW )
        led_mode = 25;
    if ( mode == LED_MIDLE )
        led_mode = 12;
    if ( mode == LED_FAST )
        led_mode = 5;
 }

//*************************************************************************************************
// Возвращает статус наличие питания контроллера по цепи +24V
// Через ScanData() по маске не работает.
// return = true  - есть питание контроллера
//        = false - питание не включено
//*************************************************************************************************
bool Fuse24Vdc( void ) {

    return !GPIO_PinRead( PORT4, FUSE24VDC );
 }

//*************************************************************************************************
// Возвращает статус состояние автомата подключения АКБ
// Через ScanData() по маске не работает.
// return = true  - автомат включен
//        = false - автомат выключен
//*************************************************************************************************
bool BatConn( void ) {

    return !GPIO_PinRead( PORT3, BAT_ON );
 }

//*************************************************************************************************
// Возвращает статус состояние уст-ва защитного отключения
// Через ScanData() по маске не работает.
// return = true  - защита сработала
//        = false - защита в норме
//*************************************************************************************************
//bool StatUZFS( void ) {
//
//    return !GPIO_PinRead( PORT3, UZFS );
// }

//*************************************************************************************************
// Контроль включения схемы управления контакторами
// Возвращает состояние наличия питания +12BAT от схемы управления контакторами
// Через ScanData() по маске не работает.
// return = true  - управление контакторами включено
//        = false - управление выключено
//*************************************************************************************************
bool StatCtrl( void ) {

    return !GPIO_PinRead( PORT3, CNTRL_ON );
 }

//*************************************************************************************************
// Возвращает наличия установленной SD карты
// return = true  - SD карта установлена
//        = false - SD карты нет
//*************************************************************************************************
bool SDDetect( void ) {

    if ( GPIO_PinRead( PORT4, SD_DETECT ) )
        return false; //карты нет
    return true;      //карта установлена
 }

//*************************************************************************************************
// Читает состояние портов ввода из функции ScanData() для подавления дребезга контактов
//*************************************************************************************************
static uint32_t ScanDataPort( void ) {

    uint32_t p0, p2, p3, p4, p5, tmp;
    
    p0 = GPIO_PortRead( PORT0 ) & 0xFB800000;   // 1111 1011 1000 0000 0000 0000 0000 0000
    p2 = GPIO_PortRead( PORT2 ) & 0x000003F8;   // 0000 0000 0000 0000 0000 0011 1111 1000
    p5 = GPIO_PortRead( PORT5 ) & 0x00000003;   // 0000 0000 0000 0000 0000 0000 0000 0011
    p3 = GPIO_PortRead( PORT3 ) & 0x048000F7;   // 0000 0100 1000 0000 0000 0000 1111 0111
    p4 = GPIO_PortRead( PORT4 ) & 0x8000E0C0;   // 1000 0000 0000 0000 1110 0000 1100 0000
    //
    p2 >>= 1;                                   // 0000 0000 0000 0000 0000 0001 1111 1100
    p0 |= p2 | p5;                              // 0000 0000 0000 0000 0000 0000 0000 0011
    //
    tmp = p3 & 0x04000000;                      // 0000 0100 0000 0000 0000 0000 0000 0000
    p0 |= tmp;                                  // 1111 1011 1000 0000 0000 0001 1111 1111
    tmp = p3 & 0x00800000;                      // 0000 0000 1000 0000 0000 0000 0000 0000
    tmp >>= 1;                                  // 0000 0000 0100 0000 0000 0000 0000 0000
    p0 |= tmp;                                  // 1111 1111 1100 0000 0000 0001 1111 1111
    tmp = p3 & 0x000000F0;                      // 0000 0000 0000 0000 0000 0000 1111 0000
    tmp <<= 14;                                 // 0000 0000 0011 1100 0000 0000 0000 0000
    p0 |= tmp;                                  // 1111 1111 1111 1100 0000 0001 1111 1111
    tmp = p3 & 0x00000007;                      // 0000 0000 0000 0000 0000 0000 0000 0111
    tmp <<= 15;                                 // 0000 0000 0000 0011 1000 0000 0000 0000
    p0 |= tmp;                                  // 1111 1111 1111 1111 1000 0001 1111 1111
    //
    tmp = p4 & 0x0000E000;                      // 0000 0000 0000 0000 1110 0000 0000 0000
    tmp >>= 1;                                  // 0000 0000 0000 0000 0111 0000 0000 0000
    p0 |= tmp;                                  // 1111 1111 1111 1111 1111 0001 1111 1111
    tmp = p4 & 0x80000000;                      // 1000 0000 0000 0000 0000 0000 0000 0000
    tmp >>= 20;                                 // 0000 0000 0000 0000 0000 1000 0000 0000
    p0 |= tmp;                                  // 1111 1111 1111 1111 1111 1001 1111 1111
    tmp = p4 & 0x000000C0;                      // 0000 0000 0000 0000 0000 0000 1100 0000
    tmp <<= 3;                                  // 0000 0000 0000 0000 0000 0110 0000 0000
    p0 |= tmp;                                  // 1111 1111 1111 1111 1111 1111 1111 1111
    p0 = ~p0;
    return p0;
 }

//*************************************************************************************************
// Результат сканирования входов с подавлением дребезга контактов
// uint32_t mask - маска для фильтрации состояний
//*************************************************************************************************
uint32_t GetDataPort( uint32_t mask ) {

    return result_scan & mask;
 }
